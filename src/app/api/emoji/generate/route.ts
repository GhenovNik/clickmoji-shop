import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { UTApi } from 'uploadthing/server';
import OpenAI from 'openai';
import { GoogleGenAI } from '@google/genai';

const utapi = new UTApi();

async function generateWithGemini(productName: string, apiKey: string): Promise<Buffer> {
  const prompt = `
Vector illustration icon of ${productName}.
Style: 3D emoji style, semi-flat look with soft volume.
MUST BE:
smooth rounded shapes,
soft plastic-like shading,
subtle gradients for depth and volume,
gentle specular highlights,
soft even lighting,
NO shadows or drop shadows,
NO black outlines (outline-free),
no text or symbols,
centered composition,
lots of white padding,
isolated on pure white background (#FFFFFF).
High quality emoji-style icon, consistent emoji pack look.
Minimalist but detailed enough to look appetizing.
`;

  const ai = new GoogleGenAI({ apiKey });
  const imagenModel = process.env.IMAGEN_MODEL || 'imagen-4.0-generate-001';

  console.log('üé® Generating with Imagen via SDK...', { productName, model: imagenModel, prompt });

  try {
    const response = await ai.models.generateImages({
      model: imagenModel,
      prompt: prompt,
      config: {
        numberOfImages: 1,
        aspectRatio: '1:1',
      },
    });

    if (!response || !response.generatedImages) {
      console.error('‚ùå Invalid response structure:', response);
      throw new Error('Invalid response from Imagen API');
    }

    if (response.generatedImages.length === 0) {
      console.error('‚ùå No images were generated (possibly blocked by Safety Filter)');
      throw new Error(
        'No image generated by Imagen - content may have been blocked by safety filters'
      );
    }

    const imgBytes = response.generatedImages[0]?.image?.imageBytes;

    if (!imgBytes) {
      console.error('‚ùå No imageBytes in first generated image:', response.generatedImages[0]);
      throw new Error('Missing image data in Imagen response');
    }

    console.log('‚úÖ Image generated successfully via SDK');
    return Buffer.from(imgBytes, 'base64');
  } catch (error) {
    console.error('‚ùå Imagen SDK Error:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      productName,
      model: imagenModel,
      prompt,
      errorDetails: JSON.stringify(error, null, 2),
    });

    // Provide more helpful error message
    if (error instanceof Error) {
      if (error.message.includes('quota') || error.message.includes('limit')) {
        throw new Error(
          `Imagen API quota exceeded. Try switching models in .env: IMAGEN_MODEL="imagen-4.0-fast-generate-001"`
        );
      }
    }

    throw error;
  }
}

async function generateWithOpenAI(productName: string, apiKey: string): Promise<Buffer> {
  const openai = new OpenAI({ apiKey });

  const prompt = `
Vector illustration icon of ${productName}.
Style: 3D emoji style, semi-flat look with soft volume.
MUST BE:
smooth rounded shapes,
soft plastic-like shading,
subtle gradients for depth and volume,
gentle specular highlights,
soft even lighting,
NO shadows or drop shadows,
NO black outlines (outline-free),
no text or symbols,
centered composition,
lots of white padding,
isolated on pure white background (#FFFFFF).
High quality emoji-style icon, consistent emoji pack look.
Minimalist but detailed enough to look appetizing.
`;

  const result = await openai.images.generate({
    model: 'gpt-image-1.5',
    prompt,
  });

  if (!result.data || result.data.length === 0) {
    throw new Error('No image generated by GPT Image');
  }

  const imageBase64 = result.data[0].b64_json;

  if (!imageBase64) {
    throw new Error('No image data from GPT Image');
  }

  return Buffer.from(imageBase64, 'base64');
}

export async function POST(request: Request) {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    const session = await auth();
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { productName } = await request.json();

    if (!productName) {
      return NextResponse.json({ error: 'Product name is required' }, { status: 400 });
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
    const provider = process.env.AI_PROVIDER || 'gemini';

    console.log(`üé® Generating AI emoji for "${productName}" using ${provider}`);

    let imageBuffer: Buffer;

    if (provider === 'gpt-image') {
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });
      }
      imageBuffer = await generateWithOpenAI(productName, apiKey);
    } else {
      const apiKey = process.env.GOOGLE_GENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'Google Generative AI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithGemini(productName, apiKey);
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    const fileName = `ai-emoji-${productName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.png`;

    // –°–æ–∑–¥–∞–µ–º File –æ–±—ä–µ–∫—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ (–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Buffer –≤ Uint8Array)
    const file = new File([new Uint8Array(imageBuffer)], fileName, { type: 'image/png' });

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ UploadThing
    console.log('üì§ Uploading to UploadThing:', fileName);
    const uploadResult = await utapi.uploadFiles(file);

    if (!uploadResult || uploadResult.error) {
      console.error('Upload error:', uploadResult?.error);
      return NextResponse.json({ error: 'Failed to upload image to storage' }, { status: 500 });
    }

    const imageUrl = uploadResult.data?.url;

    if (!imageUrl) {
      return NextResponse.json({ error: 'Upload succeeded but no URL returned' }, { status: 500 });
    }

    console.log('‚úÖ AI emoji generated and uploaded:', imageUrl);

    return NextResponse.json({
      imageUrl,
      fileName,
    });
  } catch (error) {
    console.error('Error generating AI emoji:', error);

    // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      { error: `Failed to generate emoji: ${errorMessage}` },
      { status: 500 }
    );
  }
}
