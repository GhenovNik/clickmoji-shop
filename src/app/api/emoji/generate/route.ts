import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { UTApi } from 'uploadthing/server';
import OpenAI from 'openai';
import { GoogleGenAI } from '@google/genai';

const utapi = new UTApi();

async function generateWithGemini(productName: string, apiKey: string): Promise<Buffer> {
  const prompt = `Vector illustration icon of ${productName}. Style: Semi-flat design, soft gradient vector. MUST BE: clean shapes, NO black outlines (outline-free), subtle gradients to show depth and volume. Soft lighting, cute and friendly aesthetic. Smooth rounded corners. Vibrant, saturated, appetizing colors. Isolated on white background. High quality UI icon, stock vector style. Minimalist but detailed enough to be appetizing.`;

  const ai = new GoogleGenAI({ apiKey });

  console.log('üé® Generating with Imagen via SDK...', { productName, prompt });

  try {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        aspectRatio: '1:1',
      },
    });

    if (!response || !response.generatedImages) {
      console.error('‚ùå Invalid response structure:', response);
      throw new Error('Invalid response from Imagen API');
    }

    if (response.generatedImages.length === 0) {
      console.error('‚ùå No images were generated (possibly blocked by Safety Filter)');
      throw new Error('No image generated by Imagen - content may have been blocked by safety filters');
    }

    const imgBytes = response.generatedImages[0]?.image?.imageBytes;

    if (!imgBytes) {
      console.error('‚ùå No imageBytes in first generated image:', response.generatedImages[0]);
      throw new Error('Missing image data in Imagen response');
    }

    console.log('‚úÖ Image generated successfully via SDK');
    return Buffer.from(imgBytes, 'base64');

  } catch (error) {
    console.error('‚ùå Imagen SDK Error:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      productName,
      prompt,
      error
    });
    throw error;
  }
}

async function generateWithOpenAI(productName: string, apiKey: string): Promise<Buffer> {
  const openai = new OpenAI({ apiKey });

  const prompt = `Flat vector emoji icon of ${productName}. Minimalist cartoon style, clean bold lines, solid vibrant colors, no gradients, no shadows. Friendly and simple design. Isolated on white background, centered, filling the frame. Similar to Twitter (Twemoji) or flat UI icons. NOT realistic, NOT 3D. High quality vector art. NO text.`;

  const result = await openai.images.generate({
    model: 'gpt-image-1.5',
    prompt,
  });

  if (!result.data || result.data.length === 0) {
    throw new Error('No image generated by GPT Image');
  }

  const imageBase64 = result.data[0].b64_json;

  if (!imageBase64) {
    throw new Error('No image data from GPT Image');
  }

  return Buffer.from(imageBase64, 'base64');
}

export async function POST(request: Request) {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    const session = await auth();
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { productName } = await request.json();

    if (!productName) {
      return NextResponse.json(
        { error: 'Product name is required' },
        { status: 400 }
      );
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
    const provider = process.env.AI_PROVIDER || 'gemini';

    console.log(`üé® Generating AI emoji for "${productName}" using ${provider}`);

    let imageBuffer: Buffer;

    if (provider === 'gpt-image') {
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'OpenAI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithOpenAI(productName, apiKey);
    } else {
      const apiKey = process.env.GOOGLE_GENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'Google Generative AI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithGemini(productName, apiKey);
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    const fileName = `ai-emoji-${productName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.png`;

    // –°–æ–∑–¥–∞–µ–º File –æ–±—ä–µ–∫—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ (–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Buffer –≤ Uint8Array)
    const file = new File([new Uint8Array(imageBuffer)], fileName, { type: 'image/png' });

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ UploadThing
    console.log('üì§ Uploading to UploadThing:', fileName);
    const uploadResult = await utapi.uploadFiles(file);

    if (!uploadResult || uploadResult.error) {
      console.error('Upload error:', uploadResult?.error);
      return NextResponse.json(
        { error: 'Failed to upload image to storage' },
        { status: 500 }
      );
    }

    const imageUrl = uploadResult.data?.url;

    if (!imageUrl) {
      return NextResponse.json(
        { error: 'Upload succeeded but no URL returned' },
        { status: 500 }
      );
    }

    console.log('‚úÖ AI emoji generated and uploaded:', imageUrl);

    return NextResponse.json({
      imageUrl,
      fileName
    });

  } catch (error) {
    console.error('Error generating AI emoji:', error);

    // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      { error: `Failed to generate emoji: ${errorMessage}` },
      { status: 500 }
    );
  }
}
