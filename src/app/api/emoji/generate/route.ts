import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { UTApi } from 'uploadthing/server';
import OpenAI from 'openai';
import { GoogleGenAI } from '@google/genai';

const utapi = new UTApi();

async function generateWithGemini(productName: string, apiKey: string): Promise<Buffer> {
  const prompt = `A single vector icon of ${productName}. Clearly isolated on a white background, centered in the frame. Cute 3D emoji style with soft volumetric gradients and glossy plastic texture. Minimalist design, rounded shapes, soft studio lighting, high detail, 4k resolution. NO TEXT, NO LETTERS, NO WORDS - only the icon itself.`;

  const ai = new GoogleGenAI({ apiKey });

  console.log('üé® Generating with Imagen via SDK...', { productName, prompt });

  try {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        aspectRatio: '1:1',
      },
    });

    if (!response || !response.generatedImages) {
      console.error('‚ùå Invalid response structure:', response);
      throw new Error('Invalid response from Imagen API');
    }

    if (response.generatedImages.length === 0) {
      console.error('‚ùå No images were generated (possibly blocked by Safety Filter)');
      throw new Error('No image generated by Imagen - content may have been blocked by safety filters');
    }

    const imgBytes = response.generatedImages[0]?.image?.imageBytes;

    if (!imgBytes) {
      console.error('‚ùå No imageBytes in first generated image:', response.generatedImages[0]);
      throw new Error('Missing image data in Imagen response');
    }

    console.log('‚úÖ Image generated successfully via SDK');
    return Buffer.from(imgBytes, 'base64');

  } catch (error) {
    console.error('‚ùå Imagen SDK Error:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      productName,
      prompt,
      error
    });
    throw error;
  }
}

async function generateWithDALLE(productName: string, apiKey: string): Promise<Buffer> {
  const openai = new OpenAI({ apiKey });

  const prompt = `A cute cartoon car shaped like ${productName}, vehicle design, automotive style, colorful illustration, white background, fun creative concept art`;

  const response = await openai.images.generate({
    model: 'dall-e-3',
    prompt,
    n: 1,
    size: '1024x1024',
    quality: 'standard',
    response_format: 'b64_json',
  });

  if (!response.data || response.data.length === 0) {
    throw new Error('No image generated by DALL-E');
  }

  const base64Image = response.data[0].b64_json;

  if (!base64Image) {
    throw new Error('No image data from DALL-E');
  }

  return Buffer.from(base64Image, 'base64');
}

export async function POST(request: Request) {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    const session = await auth();
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { productName } = await request.json();

    if (!productName) {
      return NextResponse.json(
        { error: 'Product name is required' },
        { status: 400 }
      );
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
    const provider = process.env.AI_PROVIDER || 'gemini';

    console.log(`üé® Generating AI emoji for "${productName}" using ${provider}`);

    let imageBuffer: Buffer;

    if (provider === 'dalle') {
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'OpenAI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithDALLE(productName, apiKey);
    } else {
      const apiKey = process.env.GOOGLE_GENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'Google Generative AI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithGemini(productName, apiKey);
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    const fileName = `ai-emoji-${productName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.png`;

    // –°–æ–∑–¥–∞–µ–º File –æ–±—ä–µ–∫—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ (–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Buffer –≤ Uint8Array)
    const file = new File([new Uint8Array(imageBuffer)], fileName, { type: 'image/png' });

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ UploadThing
    console.log('üì§ Uploading to UploadThing:', fileName);
    const uploadResult = await utapi.uploadFiles(file);

    if (!uploadResult || uploadResult.error) {
      console.error('Upload error:', uploadResult?.error);
      return NextResponse.json(
        { error: 'Failed to upload image to storage' },
        { status: 500 }
      );
    }

    const imageUrl = uploadResult.data?.url;

    if (!imageUrl) {
      return NextResponse.json(
        { error: 'Upload succeeded but no URL returned' },
        { status: 500 }
      );
    }

    console.log('‚úÖ AI emoji generated and uploaded:', imageUrl);

    return NextResponse.json({
      imageUrl,
      fileName
    });

  } catch (error) {
    console.error('Error generating AI emoji:', error);

    // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      { error: `Failed to generate emoji: ${errorMessage}` },
      { status: 500 }
    );
  }
}
