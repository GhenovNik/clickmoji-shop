import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { UTApi } from 'uploadthing/server';
import OpenAI from 'openai';
import { GoogleGenAI } from '@google/genai';
import { getEmojiGenerationPrompt } from '@/lib/prompts/emoji-generation';

const utapi = new UTApi();

async function generateWithGemini(productName: string, apiKey: string): Promise<Buffer> {
  const prompt = getEmojiGenerationPrompt(productName);

  const ai = new GoogleGenAI({ apiKey });
  const imagenModel = process.env.IMAGEN_MODEL || 'imagen-4.0-generate-001';

  console.log('üé® Generating with Imagen via SDK...', { productName, model: imagenModel, prompt });

  try {
    const response = await ai.models.generateImages({
      model: imagenModel,
      prompt: prompt,
      config: {
        numberOfImages: 1,
        aspectRatio: '1:1',
      },
    });

    if (!response || !response.generatedImages) {
      console.error('‚ùå Invalid response structure:', response);
      throw new Error('Invalid response from Imagen API');
    }

    if (response.generatedImages.length === 0) {
      console.error('‚ùå No images were generated (possibly blocked by Safety Filter)');
      throw new Error(
        'No image generated by Imagen - content may have been blocked by safety filters'
      );
    }

    const imgBytes = response.generatedImages[0]?.image?.imageBytes;

    if (!imgBytes) {
      console.error('‚ùå No imageBytes in first generated image:', response.generatedImages[0]);
      throw new Error('Missing image data in Imagen response');
    }

    console.log('‚úÖ Image generated successfully via SDK');
    return Buffer.from(imgBytes, 'base64');
  } catch (error) {
    console.error('‚ùå Imagen SDK Error:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      productName,
      model: imagenModel,
      prompt,
      errorDetails: JSON.stringify(error, null, 2),
    });

    // Provide more helpful error message
    if (error instanceof Error) {
      if (error.message.includes('quota') || error.message.includes('limit')) {
        throw new Error(
          `Imagen API quota exceeded. Try switching models in .env: IMAGEN_MODEL="imagen-4.0-fast-generate-001"`
        );
      }
    }

    throw error;
  }
}

async function generateWithOpenAI(productName: string, apiKey: string): Promise<Buffer> {
  const openai = new OpenAI({ apiKey });
  const prompt = getEmojiGenerationPrompt(productName);

  const result = await openai.images.generate({
    model: 'gpt-image-1.5',
    prompt,
  });

  if (!result.data || result.data.length === 0) {
    throw new Error('No image generated by GPT Image');
  }

  const imageBase64 = result.data[0].b64_json;

  if (!imageBase64) {
    throw new Error('No image data from GPT Image');
  }

  return Buffer.from(imageBase64, 'base64');
}

export async function POST(request: Request) {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    const session = await auth();
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { productName } = await request.json();

    if (!productName) {
      return NextResponse.json({ error: 'Product name is required' }, { status: 400 });
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
    const provider = process.env.AI_PROVIDER || 'gemini';

    console.log(`üé® Generating AI emoji for "${productName}" using ${provider}`);

    let imageBuffer: Buffer;

    if (provider === 'gpt-image') {
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });
      }
      imageBuffer = await generateWithOpenAI(productName, apiKey);
    } else {
      const apiKey = process.env.GOOGLE_GENAI_API_KEY;
      if (!apiKey) {
        return NextResponse.json(
          { error: 'Google Generative AI API key not configured' },
          { status: 500 }
        );
      }
      imageBuffer = await generateWithGemini(productName, apiKey);
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ base64 –¥–ª—è –ø—Ä–µ–≤—å—é (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ä–∞–∑—É –≤ UploadThing)
    const base64Image = `data:image/png;base64,${imageBuffer.toString('base64')}`;

    console.log('‚úÖ AI emoji generated (preview only, not uploaded yet)');

    return NextResponse.json({
      base64: base64Image,
      message: 'Image generated successfully. Will be uploaded when product is saved.',
    });
  } catch (error) {
    console.error('Error generating AI emoji:', error);

    // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      { error: `Failed to generate emoji: ${errorMessage}` },
      { status: 500 }
    );
  }
}
